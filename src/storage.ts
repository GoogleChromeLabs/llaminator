/*
 * Copyright 2021 Google Inc. All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

import * as firebase from 'firebase/storage';
import { openDB, DBSchema, IDBPDatabase } from 'idb';
import { v4 as uuidv4 } from 'uuid';

import { firebaseStorage } from './firebase';

const kMainDBName = 'appDB';
const kFirebaseDir = 'public';
const kRemoteIdPrefix = 'R-';
const kMaxDownloadSizeBytes = 5 * 1024 * 1024;

export type FileUniqueID = string; // generated by the storage layer

// TimestampUnixMillis is the number of milliseconds since Unix Epoch (midnight
// Jan 1, 1970 UTC), as generated by Date.now()
// (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now).
export type TimestampUnixMillis = number;

export type FileMetadata = {
  filename: string;
  mimeType: string;
  title?: string;
}

export type FileRecord = {
  id: FileUniqueID;
  metadata: FileMetadata;
  added: TimestampUnixMillis;
  blobModified: TimestampUnixMillis;
  metadataModified: TimestampUnixMillis;
};

interface LlamaDB extends DBSchema {
  blob: {
    key: FileUniqueID;
    value: Blob;
  };
  metadata: {
    key: FileUniqueID;
    value: FileRecord;
  };

  // miscStringVals is for any one-off string-type state that we don't want to
  // make a whole new store for.
  // TODO: consider removing this unless we come up with another purpose for it
  miscStringVals: {
    key: string;
    value: string;
  };
}

export class LlamaStorage {
  private db: IDBPDatabase<LlamaDB>;

  private constructor(db: IDBPDatabase<LlamaDB>) {
    console.log('Database initialized');
    this.db = db;
  }

  static async create() {
    return new LlamaStorage(await openDB(kMainDBName, undefined /* version */, {
      upgrade(db, oldVersion, newVersion, transaction) {
        console.log(`DB update request`);
        db.createObjectStore('blob');
        db.createObjectStore('metadata');
        db.createObjectStore('miscStringVals');
      },
      // blocked()
      // blocking()
      // terminated()
    }));
  }

  async add(file: Blob, metadata: FileMetadata): Promise<FileRecord> {
    const id: FileUniqueID = uuidv4();
    const now = Date.now();
    const record: FileRecord = {
      id: id,
      metadata: metadata,
      added: now,
      blobModified: now,
      metadataModified: now,
    };

    const tx = this.db.transaction(['blob', 'metadata'], 'readwrite');

    let uploadTask: Promise<firebase.UploadResult | null> = Promise.resolve(null);
    if (firebaseStorage) {
      // Note that as bad as this looks, security-wise, there will be server-side protection
      // against the user modifying unintended locations.
      const storageRef = firebase.ref(firebaseStorage, kFirebaseDir + '/' + id);
      const firebaseMeta: firebase.UploadMetadata = {
        contentType: metadata.mimeType,
        customMetadata: metadata,
      };
      uploadTask = firebase.uploadBytes(storageRef, file, firebaseMeta);
    }

    await Promise.allSettled([
      tx.objectStore('blob').put(file, id),
      tx.objectStore('metadata').put(record, id),
      tx.done,

      // TODO: we should allow this in the background, not have it block (and also handle errors,
      // etc)
      uploadTask,
    ]);
    console.log(`successfully added '${id}'`);
    return record;
  }

  async list(): Promise<FileRecord[]> {
    const localMeta = this.db.getAll('metadata');
    let firebaseList: firebase.ListResult | null = null;
    if (firebaseStorage) {
      firebaseList = await firebase.listAll(firebase.ref(firebaseStorage, kFirebaseDir));
    }

    const results = await localMeta;
    if (firebaseList === null) {
      return results;
    }

    // TODO: this is potentially high latency - can we load asynchronously?
    for (const res of firebaseList.items) {
      const meta = await this.getRemoteFirebaseMetadata(res);
      if (meta) {
        results.push(meta);
      }
    }

    const s: Set<string> = new Set();
    return results.filter((v: FileRecord) => {
      let id = v.id;
      if (id.startsWith(kRemoteIdPrefix)) {
        id = id.slice(kRemoteIdPrefix.length);
      }
      if (s.has(id)) {
        return false;
      }
      s.add(id);
      return true;
    });
  }

  async getFile(id: FileUniqueID): Promise<Blob | undefined> {
    if (id.startsWith(kRemoteIdPrefix)) {
      return this.getRemoteFile(id);
    }

    const blob = await this.db.get('blob', id);
    if (!blob) {
      console.log(`no blob found for id '${id}'`);
      return undefined;
    }
    console.log(`successfully retrieved blob for '${id}'`);
    return blob;
  }

  /**
   * Fetches a file's from a remote Firebase server.
   *
   * @param {FileUniqueID} remoteId - the file's remote unique id, complete with 'R-' prefix.
   * @return {Promise<FileRecord | undefined>} A promise to the file Blob if successful, or
   *     undefined if unsuccessful.
   */
  private async getRemoteFile(remoteId: FileUniqueID): Promise<Blob | undefined> {
    if (!firebaseStorage || !remoteId.startsWith(kRemoteIdPrefix)) {
      return undefined;
    }
    remoteId = remoteId.slice(kRemoteIdPrefix.length); // Trim the 'R-' prefix.

    // TODO: save a copy locally
    return firebase.getBlob(firebase.ref(firebaseStorage, kFirebaseDir + '/' + remoteId),
        kMaxDownloadSizeBytes);
  }

  async get(id: FileUniqueID): Promise<FileRecord | undefined> {
    if (id.startsWith(kRemoteIdPrefix)) {
      return this.getRemote(id);
    }

    const record = await this.db.get('metadata', id);
    if (!record) {
      console.log(`no record found for id '${id}'`);
      return undefined;
    }
    console.log(`successfully retrieved metadata for '${id}'`);
    return record;
  }

  /**
   * Fetches a file's metadata from a remote Firebase server.
   *
   * @param {FileUniqueID} remoteId - the file's remote unique id, complete with 'R-' prefix.
   * @return {Promise<FileRecord | undefined>} A promise to the FileRecord representing the file if
   *     successful, or undefined if unsuccessful.
   */
  private async getRemote(remoteId: FileUniqueID): Promise<FileRecord | undefined> {
    if (!firebaseStorage || !remoteId.startsWith(kRemoteIdPrefix)) {
      return undefined;
    }
    remoteId = remoteId.slice(kRemoteIdPrefix.length); // Trim the 'R-' prefix.

    // TODO: save a copy locally
    return this.getRemoteFirebaseMetadata(
        firebase.ref(firebaseStorage, kFirebaseDir + '/' + remoteId));
  }

  /**
   * Fetches a file's metadata from a remote Firebase server.
   *
   * @param {StorageReference} firebaseRef - the Firebase file reference.
   * @return {Promise<FileRecord | undefined>} A promise to the FileRecord representing the file if
   *     successful, or undefined if unsuccessful.
   */
  private async getRemoteFirebaseMetadata(firebaseRef: firebase.StorageReference):
    Promise<FileRecord | undefined> {
    if (!firebaseStorage) {
      return undefined;
    }

    const meta = await firebase.getMetadata(firebaseRef);
    const custMeta = meta.customMetadata as (FileMetadata | undefined);
    if (custMeta) {
      return {
        // Prefix the id with 'R-' to designate it as a remote reference.
        id: kRemoteIdPrefix + meta.name,
        metadata: custMeta,
        added: Date.parse(meta.timeCreated),
        blobModified: Date.parse(meta.updated),
        metadataModified: Date.parse(meta.updated),
      };
    }

    return undefined;
  }

  // At least one of |file| and |metadata| must be provided.
  async update(id: FileUniqueID, file?: Blob, metadata?: FileMetadata): Promise<FileRecord> {
    if (!file && !metadata) throw new TypeError('neither |file| nor |metadata| was provided');

    const tx = this.db.transaction(['blob', 'metadata'], 'readwrite');

    const now = Date.now();
    const record = await tx.objectStore('metadata').get(id);
    if (!record) throw new ReferenceError(`no record found for id '${id}'`);
    if (metadata) {
      record.metadata = metadata;
      record.metadataModified = now;
    }

    if (file) {
      record.blobModified = now;
      await tx.objectStore('blob').put(file, id);
    }

    await tx.objectStore('metadata').put(record, id);
    await tx.done;
    console.log(`successfully updated '${id}'`);

    return record;
  }

  /**
   * Deletes an image and its metadata from storage.
   *
   * @param {FileUniqueID} id - the file identifier.
   */
  async delete(id: FileUniqueID): Promise<void> {
    const tx = this.db.transaction(['blob', 'metadata'], 'readwrite');

    await Promise.allSettled([
      await tx.objectStore('blob').delete(id),
      await tx.objectStore('metadata').delete(id),
      await tx.done,
    ]);
    console.log(`deleted '${id}'`);
  }
}
